#!/usr/bin/env lua

-- this program name
local PROGNAME = arg[0]:match("[^/]+$")

-- trim whitespace from both ends of the string
local function trim(s) --> string
	-- see trim12 from http://lua-users.org/wiki/StringTrim
	local i = s:match("^%s*()")
	return i > #s and "" or s:match(".*%S", i)
end

-- print message and exit with error code
local function die(msg, ...)
	if select("#", ...) > 0 then
		msg = msg:format(...)
	end

	io.stderr:write(PROGNAME, ": [error] ", trim(msg), "\n")
	os.exit(false)
end

-- i/o error checker
local function just(ok, ...) --> all arguments
	if ok then
		return ok, ...
	end

	-- got an error
	local err, code = ...

	if math.type(code) == "integer" then
		if err == "exit" then -- error from os.execute or similar
			-- just exit with this code, assuming an error message has already been
			-- produced by an external program
			os.exit(code)
		end

		if err == "signal" then
			-- exit as if terminated by this signal
			os.exit(code + 128)
		end
	end

	-- terminate
	die(tostring(err))
end

-- templating
local function template_subst(templ, obj) --> string
	return templ:gsub("%f[%$]%$%{([%w_]+)%}", obj)
end

-- join `n` to `m` formatted strings around `sep`
local function gen_num_seq(n, m, s, sep) --> string
	local t = {}

	for i = n, m do
		t[#t + 1] = s:format(i)
	end

	return table.concat(t, sep)
end

-- write strings to the file
local function write_file(fname, ...)
	local dest = just(io.open(fname, "w"))

	just(dest:write(...))
	just(dest:close())
end

-- function definition templates
local FIRST_LINE = "// Code generated by `" .. PROGNAME .. "`. DO NOT EDIT.\n"

local FUNC_DEFS_HEADER = [=[
package compute

// SetFunc0 adds function without arguments to the [Pad].
func (p *Pad[K, V]) SetFunc0(key K, fn func() V) {
	p.env[key] = &formula[K, V]{fn: func(...V) V { return fn() }}
}

]=]

local FUNC_TEMPLATE = [=[
// SetFunc${num_args} adds ${num_args}-argument function to the [Pad].
func (p *Pad[K, V]) SetFunc${num_args}(key K, fn func(${func_def_args}) V, ${arg_list} K) {
	p.env[key] = &formula[K, V]{
		fn:   func(args ...V) V { return fn(${invocation_args}) },
		args: []K{${arg_list}},
	}
}
]=]

-- function definition generator
local function gen_func_defs(n) --> string
	t = {}

	for i = 1, n do
		t[#t + 1] = template_subst(FUNC_TEMPLATE, {
			num_args		= i,
			func_def_args	= string.rep("V", i, ", "),
			arg_list		= gen_num_seq(0, i - 1, "arg%d", ", "),
			invocation_args	= gen_num_seq(0, i - 1, "args[%d]", ", "),
		})
	end

	return table.concat(t, "\n")
end

-- test template
local TEST_TEMPLATE = [=[
package compute

func one() int { return 1 }
func inc(a int) int { return a + 1 }
%s

func TestFunctions(t *testing.T) {
	pad := NewPad[int, int]()

	pad.SetFunc0(0, one)
	pad.SetFunc1(1, inc, 0)
%s

	res, err := calcInts(pad, %s)

	if err != nil {
		t.Fatal(err)
	}

	if !slices.Equal(res, []int{%s}) {
		t.Fatalf("unexpected result: %%v", res)
	}
}
]=]

-- test helpers
local function make_helpers(n) --> string
	local letters = { "a" }
	local a = string.byte("a")
	local res = {}

	for i = 2, n do
		letters[#letters + 1] = string.char(a + i - 1)

		res[#res + 1] = ("func add%d(%s int) int { return %s }")
						:format(i, table.concat(letters, ", "), table.concat(letters, " + "))
	end

	return table.concat(res, "\n")
end

-- test setters
local function make_test_setters(n) --> string
	local res = {}

	for i = 2, n do
		res[#res + 1] = ("\tpad.SetFunc%d(%d, add%d, %s)")
						:format(i, i, i, gen_num_seq(0, i - 1, "%d", ", "))
	end

	return table.concat(res, "\n")
end

-- test result calculator
local function calc_test_results(n) --> string
	local res = { 1, 2, 3 }

	for i = 3, n do
		res[#res + 1] = res[#res] << 1
	end

	return table.concat(res, ", ")
end

-- make test
local function gen_test(n) --> string
	return TEST_TEMPLATE:format(
		make_helpers(n),
		make_test_setters(n),
		gen_num_seq(0, n, "%d", ", "),
		calc_test_results(n)
	)
end

-- run the program
local n = 10

if arg[3] then
	n = math.tointeger(arg[3])

	if not n or n < 2 or n > 32 then
		die("invalid number of functions: %q", arg[3])
	end
end

-- file names
local funcs = arg[1] or die("function definition file is not specified")
local tests = arg[2] or die("test file is not specified")

-- write files
write_file(funcs, FIRST_LINE, FUNC_DEFS_HEADER, gen_func_defs(n))
write_file(tests, FIRST_LINE, gen_test(n))

-- format files
just(os.execute(("goimports -w '%s' '%s'"):format(funcs, tests)))
