#!/usr/bin/env lua

-- this program name
local PROGNAME = arg[0]:match("[^/]+$")

-- trim whitespace from both ends of the string
local function trim(s) --> string
	-- see trim12 from http://lua-users.org/wiki/StringTrim
	local i = s:match("^%s*()")
	return i > #s and "" or s:match(".*%S", i)
end

-- print message and exit with error code
local function die(msg, ...)
	if select("#", ...) > 0 then
		msg = msg:format(...)
	end

	io.stderr:write(PROGNAME, ": [error] ", trim(msg), "\n")
	os.exit(false)
end

-- i/o error checker
local function just(ok, ...) --> all arguments
	if ok then
		return ok, ...
	end

	-- got an error
	local err, code = ...

	if math.type(code) == "integer" then
		if err == "exit" then -- error from os.execute or similar
			-- just exit with this code, assuming an error message has already been
			-- produced by an external program
			os.exit(code)
		end

		if err == "signal" then
			-- exit as if terminated by this signal
			os.exit(code + 128)
		end
	end

	-- terminate
	die(tostring(err))
end

-- join `n` formatted strings around `sep`
local function repeat_n(n, s, sep) --> string
	local t = {}

	for i = 0, n - 1 do
		t[#t + 1] = s:format(i)
	end

	return table.concat(t, sep)
end

-- function definition tamplate
local func_template = [=[

// SetFunc%d adds %d-argument function to the [Pad].
func (p *Pad[K, V]) SetFunc%d(key K, fn func(%s) V, %s K) {
	p.env[key] = &formula[K, V]{
		fn:   func(args ...V) V { return fn(%s) },
		args: []K{%s},
	}
}
]=]

local first_line = "// Code generated by `" .. PROGNAME .. "`. DO NOT EDIT.\n"
local func_header = first_line .. [=[
package compute

// SetFunc0 adds function without arguments to the [Pad].
func (p *Pad[K, V]) SetFunc0(key K, fn func() V) {
	p.env[key] = &formula[K, V]{fn: func(...V) V { return fn() }}
}
]=]

-- write function definitions
local function write_func_defs(fname, n)
	local dest = just(io.open(fname, "w"))

	just(dest:write(func_header))

	for i = 1, n do
		local fn_def = string.rep("V", i, ", ")
		local args = repeat_n(i, "arg%d", ", ")
		local arr = repeat_n(i, "args[%d]", ", ")

		just(dest:write(func_template:format(i, i, i, fn_def, args, arr, args)))
	end

	just(dest:close())
end

-- header for test file
local test_header = first_line .. [=[
package compute

func one() int { return 1 }
func inc(a int) int { return a + 1 }
]=]

-- write test helpers
local function write_helpers(dest, n)
	just(dest:write(test_header))

	local t = { "a" }
	local a = string.byte("a")

	for i = 2, n do
		t[#t + 1] = string.char(a + i - 1)

		local s = ("func add%d(%s int) int { return %s }\n")
				  :format(i, table.concat(t, ", "), table.concat(t, " + "))

		just(dest:write(s))
	end
end

local test_func_header = [=[

func TestFunctions(t *testing.T) {
	pad := NewPad[int, int]()

	pad.SetFunc0(0, one)
	pad.SetFunc1(1, inc, 0)
]=]

local test_function_footer = [=[

	res, err := calcInts(pad, %s)

	if err != nil {
		t.Fatal(err)
	}

	if !slices.Equal(res, []int{%s}) {
		t.Fatalf("unexpected result: %%v", res)
	}
}
]=]

-- write test function
local function write_test_func(dest, n)
	just(dest:write(test_func_header))

	local res = { 1, 2 }
	local sum = 3

	for i = 2, n do
		local s = ("\tpad.SetFunc%d(%d, add%d, %s)\n")
				  :format(i, i, i, repeat_n(i, "%d", ", "))

		just(dest:write(s))

		res[#res + 1] = sum
		sum = sum << 1
	end

	local s = test_function_footer
			  :format(repeat_n(n + 1, "%d", ", "), table.concat(res, ", "))

	just(dest:write(s))
end

-- write test file
local function write_test(fname, n)
	local dest = just(io.open(fname, "w"))

	write_helpers(dest, n)
	write_test_func(dest, n)
	just(dest:close())
end

-- run the program
local n = 8

if arg[3] then
	n = math.tointeger(arg[3])

	if not n or n <= 0 or n > 16 then
		die("invalid number of functions: '%s'", arg[3])
	end
end

-- file names
local funcs = arg[1] or die("function definition file is not specified")
local tests = arg[2] or die("test file is not specified")

-- write files
write_func_defs(funcs, n)
write_test(tests, n)

-- format files
just(os.execute(("goimports -w '%s' '%s'"):format(funcs, tests)))
